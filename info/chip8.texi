\input texinfo
@include version.texi
@setfilename chip8.info
@settitle Chip-8 @value{VERSION}
@syncodeindex fn cp

@copying
This manual is for Chip-8, version @value{VERSION}.

Copyright @copyright{} 2017 Ian Johnson

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end copying

@titlepage
@title Chip-8 Reference
@subtitle Version @value{VERSION}
@author Ian Johnson (@email{ianprime0509@@gmail.com})

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Print the table of contents at the start.
@contents

@ifnottex
@node Top
@top Chip-8 Reference Guide

This is a reference guide for the Chip-8 interpreter and assembler
developed by Ian Johnson.  It also contains documentation on the Chip-8
and Super-Chip platforms themselves.
@end ifnottex

@menu
* Overview::        Overview of the Chip-8 project.
* The Chip-8 and Super-Chip::      Description of the emulated platforms.
* The emulator::    Documentation for the emulator.
* The assembler::   Documentation for the assembler.
* Further reading:: More information about the Chip-8 and Super-Chip.
* GNU Free Documentation License::   Your freedoms.
* Index::           Complete index.
@end menu

@node Overview
@chapter Overview
@cindex overview

An overview goes here.

@node The Chip-8 and Super-Chip
@chapter The Chip-8 and Super-Chip
@cindex Chip-8
@cindex Super-Chip

@menu
* External hardware::    The display, buzzer and controller.
* Internal hardware::    Registers, instructions and more.
@end menu

@node External hardware
@section External hardware
@cindex external hardware
@cindex hardware, external

@node Internal hardware
@section Internal hardware
@cindex internal hardware
@cindex hardware, internal

@node The emulator
@chapter The emulator
@cindex emulator

This package comes with a Chip-8/Super-Chip emulator, invoked as
@command{chip8}, which aims to correctly emulate as many Chip-8 and
Super-Chip games as possible while offering user configuration where
applicable.  Currently, all the Chip-8 games I have tested work without
issue, while some Super-Chip games need more work.

Since both the original Chip-8 and Super-Chip were interpreters running
on other machines rather than deedicated hardware, the terms
``emulator'' and ``interpreter'' will be used interchangeably when
referring to @command{chip8}.

@menu
* Invoking chip8::      Using the emulator.
@end menu

@node Invoking chip8
@section Invoking @command{chip8}
@cindex @command{chip8} (command)

Fill this in...

@node The assembler
@chapter The assembler
@cindex assembler

@menu
* Invoking chip8asm::   Using the assembler.
* Syntax::              Overview of assembler syntax.
* Operations::          The various operations used as instructions.
@end menu

@node Invoking chip8asm
@section Invoking @command{chip8asm}
@cindex invoking assembler
@cindex assembler, invocation

Nothing here yet...

@node Syntax
@section Syntax
@cindex syntax
@cindex assembler syntax

@node Line format
@subsection Line format
@cindex line format
@cindex assembler line format

The syntax used in the assembler is similar to that used in the popular
CHIPPER assembler.  The assembly input is processed one line at a time,
where each line may consist of a label and/or an instruction.  Blank
lines are also allowed, for readability.  A semicolon, @samp{;}, may be
used to begin a comment; the rest of the line following the semicolon
will be ignored.

A label consists of an identifier followed by a colon, @samp{:}, and
must be the first element on its line (optionally preceded by
whitespace).  An identifier may start with an underscore or alphabetic
character, and may additionally contain the digits 0--9 after the
initial character.  It is not possible to define two different labels to
refer to the same instruction, or to define two labels with the same
identifer.  Label names are case-sensitive, so @code{label1} will be
treated as a separate label from @code{LABEL1}.

An instruction consists of an operation and, depending on the operation,
a comma-separated list of operands (@pxref{Operations} for a list of
operations).  The name of the operation is not case-sensitive, so
@code{DRAW} is processed the same as @code{draw} and @code{dRaW}.
Depending on the operation, each operand of an instruction may be either
the name of a register or an expression (@pxref{Expressions}).  If a
particular operand could be interpreted either as a register name which
would be valid in its position or as an expression, the register
interpretation will be chosen.  Thus, the instruction @code{ADD V1, V2}
will always be interpreted as ``add register @code{V2} to register
@code{V1}'', and not ``add the value of the label @code{V2} to register
@code{V1}'', even if @code{V2} happens to have been defined as a label
name.

@node Expressions
@subsection Expressions
@cindex expression
@cindex assembler expression

The treatment of expressions in the assembler is similar to that used in
most programming languages, such as C: they are written in infix
notation, and label names may be used as identifiers to represent their
values.  The meanings and precedences of the operators should also be
mostly familiar to those experienced in other programming languages,
particularly C.

Since the Chip-8 is fundamentally a 16-bit machine, all quantities in
expressions are treated as 16-bit unsigned numbers.  If an expression
results in a value which is outside the range of a 16-bit unsigned
quantity, it will be converted to one by taking its residue modulo
@math{2^16}.  This is equivalent to assuming a two's-complement
representation of signed numbers.  In cases where an expression is used
in an operand which is narrower than 16 bits (for example, the @code{JP}
operation takes a single 12-bit operand, @xref{Operations}), the result
of the expression is truncated to fit (in the example, the lowest 12
bits are kept and the highest 4 discarded).

There are two unary operators, both of which are applied to the left of
their operand: these are the unary negation operator @code{-} and the
bitwise NOT operator @code{~}.  They have a higher precedence than any
binary operator.

The binary operators, in decreasing order of precedence, are given
below; operators at the same level of precedence will be evaluated
left-to-right (e.g. they are left-associative).

@enumerate
@item
@code{*} for multiplication, @code{/} for division and @code{%} for
modulus.

@item
@code{+} for addition and @code{-} for subtraction.

@item
@code{>} and @code{<}, which are the logical right and left shifts,
respectively.  The assembler does not provide arithmetic shift
operators, since numeric quantities are always treated as unsigned.

@item
@code{&} for the bitwise AND operation.

@item
@code{^} for the bitwise XOR operation.

@item
@code{|} for the bitwise OR operation.
@end enumerate

@node Operations
@section Operations
@cindex operation
@cindex assembler operation

When speaking of operations in the assembler, we distinguish between
true operations and ``pseudo-operations''.  A true operation is one that
corresponds directly to a Chip-8 or Super-Chip instruction, such as
@code{ADD}, while a pseudo-operation does not.

@menu
* True operations::         Reference for true operations.
* Pseudo-operations::       Reference for pseudo-operations.
@end menu

@node True operations
@subsection True operations
@cindex true operation
@cindex operation, true

The operations described in this section form a complete description of
the Chip-8/Super-Chip instruction set.  Every instruction used by the
Chip-8 or Super-Chip is represented by a two-byte opcode,
@pxref{Internal hardware}.

@menu
* Operation notation::  Conventions for writing operations and opcodes.
* Operation reference:: List of all operations with their opcodes.
* Alternative behavior:: Different treatment by other interpreters.
@end menu

@node Operation notation
@subsubsection Operation notation
@cindex operation notation
@cindex notation, operation

For consistency and readability, we will use certain conventions to
denote the operands taken by each operation.  For operands which must be
a certain literal value, this value is used (e.g. the @code{DT} in
@code{LD DT, Vx}).  For register operands, we use @var{vx} and @var{vy}
as placeholders for the register names.  For other quantities, we use
@var{addr} for 12-bit addresses, @var{byte} for 8-bit quantities and
@var{nibble} for 4-bit quantities.

The opcodes corresponding to each instruction (operation with operands)
follow a parallel convention.  Each opcode consists of four alphanumeric
characters, corresponding to the four digits in its hexadecimal
representation.  A hexadecimal digit (with letters written in uppercase)
in a particular position indicates that that same digit is present in
the opcode, while lowercase letters indicate that the value of some
operand should be substituted in their position according to the table
below.

@table @samp
@item x
The index of register @var{vx}.

@item y
The index of register @var{vy}.

@item nnn
The 12-bit value of the address @var{addr}.

@item kk
The 8-bit value of the byte @var{byte}.

@item n
The 4-bit value of the nibble @var{nibble}.
@end table

For example, the instruction @code{DRW @var{vx}, @var{vy}, @var{nibble}}
has opcode @samp{Dxyn} according to this convention, indicating that the
concrete instruction @code{DRW V1, VA, 5} has opcode @samp{D1A5}.

@node Operation reference
@subsubsection Operation reference
@cindex operation reference

@deffn Operation SCD nibble
This operation scrolls the screen down by @var{nibble} pixels.  It is
only available on the Super-Chip, and its opcode is @samp{00Cn}.
@end deffn

@deffn Operation CLS
This operation clears the entire display.  Its opcode is @samp{00E0}.
@end deffn

@deffn Operation RET
This operation returns from a subroutine; it is an error to use
@code{RET} without a corresponding preceding @code{CALL}.  Its opcode is
@samp{00EE}.
@end deffn

@deffn Operation SCR
This operation scrolls the screen right by 4 pixels.  It is only
available on the Super-Chip, and its opcode is @samp{00FB}.
@end deffn

@deffn Operation SCL
This operation scrolls the screen left by 4 pixels.  It is only
available on the Super-Chip, and its opcode is @samp{00FC}.
@end deffn

@deffn Operation EXIT
This operation signals to the interpreter to exit immediately.  It is
only available on the Super-Chip, and its opcode is @samp{00FD}.
@end deffn

@deffn Operation LOW
This operation switches the display to low-resolution mode
(@pxref{External hardware}).  It is only available on the Super-Chip,
and its opcode is @samp{00FE}.
@end deffn

@deffn Operation HIGH
This operation switches the display to high-resolution mode
(@pxref{External hardware}).  It is only available on the Super-Chip,
and its opcode is @samp{00FF}.
@end deffn

@deffn Operation JP addr
This operation sets the program counter to @var{addr}.  It is an error
to jump to an address which is not aligned on a 2-byte boundary.  Its
opcode is @samp{1nnn}.
@end deffn

@deffn Operation CALL addr
This operation calls the subroutine at @var{addr}; that is, it sets the
program counter to @var{addr} and pushes the original program counter to
the call stack so that it can be returned to using @code{RET}.  It is an
error to call a subroutine which is not aligned on a 2-byte boundary.
Its opcode is @samp{2nnn}.
@end deffn

@deffn Operation SE vx, byte
This operation skips the next instruction if the value of @var{vx} is
equal to @var{byte}.  Its opcode is @samp{3xkk}.
@end deffn

@deffn Operation SNE vx, byte
This operation skips the next instruction if the value of @var{vx} is
not equal to @var{byte}.  Its opcode is @samp{4xkk}.
@end deffn

@deffn Operation SE vx, vy
This operation skips the next instruction if the values of @var{vx} and
@var{vy} are equal.  Its opcode is @samp{5xy0}.
@end deffn

@deffn Operation LD vx, byte
This operation loads @var{byte} into register @var{vx}.  Its opcode is
@samp{6xkk}.
@end deffn

@deffn Operation ADD vx, byte
This operation adds @var{byte} to the value of register @var{vx},
storing the result (modulo 256) in @var{vx}.  Register @code{VF} is set
to 1 if a carry occurred (that is, if the true sum was greater than or
equal to 256), or 0 otherwise.  Its opcode is @samp{7xkk}.
@end deffn

@deffn Operation LD vx, vy
This operation loads the value of @var{vy} into @var{vx}.  Its opcode is
@samp{8xy0}.
@end deffn

@deffn Operation OR vx, vy
This operation computes the bitwise OR of @var{vx} and @var{vy}, storing
the result in @var{vx}.  Its opcode is @samp{8xy1}.
@end deffn

@deffn Operation AND vx, vy
This operation computes the bitwise AND of @var{vx} and @var{vy},
storing the result in @var{vx}.  Its opcode is @samp{8xy2}.
@end deffn

@deffn Operation XOR vx, vy
This operation computes the bitwise XOR of @var{vx} and @var{vy},
storing the result in @var{vx}.  Its opcode is @samp{8xy3}.
@end deffn

@deffn Operation ADD vx, vy
This operation adds the value of @var{vy} to that of @var{vx}, storing
the result (modulo 256) in @var{vx}.  Register @code{VF} is set to 1 if
a carry occurred, or 0 otherwise.  Its opcode is @samp{8xy4}.
@end deffn

@deffn Operation SUB vx, vy
This operation subtracts the value of @var{vy} from that of @var{vx},
storing the result (modulo 256) in @var{vx}.  Register @code{VF} is set
to 0 if a borrow occurred (that is, if the true value of the difference
would be negative under signed arithmetic), or to 1 otherwise.  Its
opcode is @samp{8xy5}.
@end deffn

@deffn Operation SHR vx
This operation performs a logical right shift on the value of @var{vx},
storing the result in @var{vx}.  The original least significant bit of
@var{vx} is stored in register @code{VF}.  Its opcode is @samp{8x06}.
@end deffn

@node Alternative behavior
@subsubsection Alternative behavior
@cindex alternative behavior (of operations)

Some interpreters do not behave exactly as described in the operation
reference, and some games are developed which rely on these alternatve
behaviors.  Currently, the only such known variant behavior is with the
shift operations @code{SHR} and @code{SHL}, described below.  The
interpreter (@pxref{Invoking chip8}) and assembler (@pxref{Invoking
chip8asm}) both accept a flag instructing them to use these variant
forms.

@node Pseudo-operations
@subsection Pseudo-operations
@cindex pseudo-operation
@cindex operation, pseudo-

The first important class of pseudo-operations are those which provide
support for conditional assembly, that is, emitting different assembly
instructions based on a assemble-time condition.

@deffn Pseudo-operation IFDEF label
This pseudo-operation begins a conditional assembly block.  If
@var{label} is defined when @code{IFDEF} is processed, then all
instructions up to the matching @code{ELSE} or @code{ENDIF} are
processed, and any instructions following the @code{ELSE} (if present)
until the matching @code{ENDIF} are ignored.  If @var{label} is
undefined, then the assembler ignores all instructions until the
matching @code{ELSE} or @code{ENDIF}, instead processing those which
follow @code{ELSE} (if present).
@end deffn

@deffn Pseudo-operation IFNDEF label
This pseudo-operation is the opposite of @code{IFDEF}: if @var{label} is
undefined, the conditional assembly is processed until @code{ELSE} and
then ignored until @code{ENDIF}, and vice versa if @var{label} is
defined.
@end deffn

@deffn Pseudo-operation ELSE
This pseudo-operation marks the beginning of the assembly instructions
to be processed if the corresponding conditional was false, or to be
ignored if the corresponding conditional was true.  It may be used at
most once within a block of conditional assembly.
@end deffn

@deffn Pseudo-operation ENDIF
This pseudo-operation marks the end of a block of conditional assembly.
@end deffn

The second important class of pseudo-operations are those which modify
the value of labels.  The most general of these is the special @code{=}
pseudo-operation, which is used with the syntax @code{@var{label} =
@var{expression}}, setting the value of @var{label} to the result of
@var{expression}.

@deffn Pseudo-operation DEFINE label
This is equivalent to @code{@var{label} = 0}, and indicates that
@var{label} will be used not for its value, but as a flag for
conditional compilation using @code{IFDEF} or @code{IFNDEF}.
@end deffn

The third important class of pseudo-operations are those which insert
literal bytes into the assembled output.

@deffn Pseudo-operation DW expression
This pseudo-operation evaluates @var{expression} and inserts the result
(treated as a big-endian 16-bit unsigned integer) into the assembled
output.  For example, @code{DW #1234} will insert the bytes @code{#12}
and @code{#34} (in that order) into the assembled output.
@end deffn

@deffn Pseudo-operation DB expression
This pseudo-operation evaluates @var{expression} and inserts the result
(treated as an 8-bit unsigned integer) into the assembled output (only
the least significant 8 bits of @var{expression} are kept,
@pxref{Expressions}).  An operation following @code{DB} will be aligned
to the next 2-byte boundary to ensure that no misaligned operations are
produced; however, this alignement will not occur for pseudo-operations
such as @code{DW} and @code{DB}.
@end deffn

Finally, the last class of pseudo-operations (which currently has only
one rather useless member) are those which give a directive to the
assembler to affect the way it processes further instructions.

@deffn Pseudo-operation OPTION name
This pseudo-operation (currently) does nothing.  Eventually, different
values of @var{name} may be used to enable or disable certain assembly
modes or features.  For example, perhaps @code{OPTION SHQUIRKS} could be
used to enable shift quirks, removing the need for the @samp{-q} flag,
@pxref{Invoking chip8asm}.
@end deffn

@node Further reading
@chapter Further reading
@cindex further reading

There are several good resources on the Web for Chip-8 information. For
a Chip-8 instruction/opcode reference, see
@url{http://devernay.free.fr/hacks/chip8/C8TECH10.HTM,Cowgod's Chip-8
Technical Reference}; it also lists the opcodes for Super-Chip
instructions, but does not give their descriptions. For a collection of
many Chip-8 and Super-Chip games, as well as an emulator for DOS, see
@url{http://www.pong-story.com/chip8/,David Winter's Chip-8 page}. There
is also some documentation included with his emulator, which gives some
more background on the Chip-8, including details about some variant
implementations.

@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl.texi

@node Index
@unnumbered Index
@cindex index

@printindex cp

@bye
